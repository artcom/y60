//=============================================================================
// Copyright (C) 2003 ART+COM AG Berlin
//
// These coded instructions, statements, and computer programs contain
// unpublished proprietary information of ART+COM AG Berlin, and
// are copy protected by law. They may not be disclosed to third parties
// or copied or duplicated in any form, in whole or in part, without the
// specific, prior written permission of ART+COM AG Berlin.
//=============================================================================

struct app2vert {
    float4 Position  : POSITION;
    float4 Normal    : NORMAL;
#ifdef PAINT
    float4 texCoord0 : TEXCOORD0;
#if PAINT==2
    float4 texCoord1 : TEXCOORD1;
#endif // PAINT==2 
#endif // PAINT
};

struct vert2frag {
    float4 homPosition    : POSITION;
#ifdef PAINT
    float2 texCoord0      : TEXCOORD0;
#if PAINT==2
    float2 texCoord1      : TEXCOORD1;
#endif
#endif // PAINT
    float4 objectPosition : TEXCOORD3;
    float4 objectNormal   : TEXCOORD4;
    float3 worldNormal    : TEXCOORD5;
    float4 homPosition2   : TEXCOORD6;
};

vert2frag mainVertex(app2vert IN,
                     uniform float4x4 GL_MODELVIEW_PROJECTION,
                     uniform float4x4 GL_MODELVIEW,
                     uniform float4x4 AC_OBJECTWORLD_IT,
                     uniform float4x4 AC_OBJECTWORLD,
                     uniform float4x4 GL_TEXTURE)
{
    vert2frag OUT;
    
    OUT.worldNormal    = normalize(mul(AC_OBJECTWORLD_IT, IN.Normal).xyz);
    OUT.homPosition    = mul(GL_MODELVIEW_PROJECTION, IN.Position);
    OUT.homPosition2   = mul(AC_OBJECTWORLD, IN.Position); 
    
    OUT.objectPosition = IN.Position;
    OUT.objectNormal   = IN.Normal;

#ifdef PAINT
    OUT.texCoord0      = mul(GL_TEXTURE, IN.texCoord0).xy;
#if PAINT==2
    OUT.texCoord1      = mul(GL_TEXTURE, IN.texCoord1).xy;
#endif
#endif // PAINT
   
    return OUT;
}

float4 mainFragment(vert2frag IN,
                    uniform float4x4 AC_OBJECTWORLD,
                    uniform float4x4 AC_OBJECTWORLD_IT,
                    uniform float4 AC_SPOT_LIGHTS_DIFFUSE_COLOR[],
                    uniform float4 AC_SPOT_LIGHTS_SPECULAR_COLOR[],
                    uniform float3 AC_SPOT_LIGHTS[],
                    uniform float3 AC_SPOT_LIGHTS_DIRECTION[],
                    uniform float AC_SPOT_LIGHTS_CUTOFF[],
                    uniform float AC_SPOT_LIGHTS_EXPONENT[],
                    uniform float AC_SPOT_LIGHTS_ATTENUATION[],
                    uniform float4 ambient,
                    uniform float4 specular,
                    uniform float penumbra,
#ifdef PAINT
                    uniform sampler2D tex0,
#if PAINT==2
                    uniform sampler2D tex1,
#endif
#endif
                    uniform float4 diffuse) : COLOR

{
    float4 myDiffuse = float4(0.0, 0.0, 0.0, 1.0);

#ifdef PAINT
    float4 myColor0 = tex2D(tex0, IN.texCoord0);
    myDiffuse = ambient * myColor0; 
#if PAINT==2
    float4 myColor1 = tex2D(tex1, IN.texCoord1);
    myDiffuse += ambient * myColor1; 
#endif
#else
    myDiffuse  = ambient*diffuse; 
#endif // PAINT
    
    float3 N = IN.worldNormal;

    // spot lights
    float3 tempPosition = IN.homPosition2.xyz;
    
    float myLightDistance = 0.0f;
    for(int i = 0; i < AC_SPOT_LIGHTS.length ; ++i) {
        // calculate spot cone
        float3 L = normalize(AC_SPOT_LIGHTS[i] - tempPosition);
        myLightDistance = distance((AC_SPOT_LIGHTS[i]).xyz, tempPosition); //IN.objectPosition.xyz);

        // calculate diffuse term
	    float NdotL = dot(N, L);
        
        if (NdotL > 0.0f) {
            float spotEffect    = dot(normalize(AC_SPOT_LIGHTS_DIRECTION[i]), normalize(-L));
            float myCosCutoff   = cos(radians(AC_SPOT_LIGHTS_CUTOFF[i]/2));
            float myCosPenumbra = cos(radians(AC_SPOT_LIGHTS_CUTOFF[i]/2 + penumbra));

            float myInnerCutoff = min(myCosPenumbra, myCosCutoff);

            if (spotEffect > myInnerCutoff) {
                float mySpotEffectExponent = pow(spotEffect, AC_SPOT_LIGHTS_EXPONENT[i]);
                myLightDistance = distance((AC_SPOT_LIGHTS[i]).xyz, tempPosition); //IN.objectPosition.xyz);
               
                float mySpotDiffuse = mySpotEffectExponent * NdotL;
                float myAttenuation = 1/(1+AC_SPOT_LIGHTS_ATTENUATION[i]*myLightDistance);
                
                float4 myLightingTerm = float4(mySpotDiffuse)*AC_SPOT_LIGHTS_DIFFUSE_COLOR[i]*myAttenuation*diffuse;

                float myOuterCutoff = max(myCosCutoff, myCosPenumbra);

                if (spotEffect < myOuterCutoff) {
                    float myLerpRange = myInnerCutoff - myOuterCutoff; 
                    float myWeight = (spotEffect-myOuterCutoff)/myLerpRange;
                    myLightingTerm*=lerp(1, 0, myWeight); 
                }

#ifdef PAINT
                myDiffuse += myLightingTerm*myColor0;
#if PAINT==2
                myDiffuse += myLightingTerm*myColor1;
#endif
#else
                myDiffuse += myLightingTerm;
#endif
            }
        }
    }
    
    float4 myReturn = myDiffuse; 
    // myReturn.a = 1.0f;
    
    return myReturn;
}
