#==============================================================================
# Generated by: @ACMAKE_GENERATOR@
#         from: @ACMAKE_TEMPLATE_FILE@
#
#             @ACMAKE_DO_NOT_EDIT_WARNING@
#==============================================================================

# This file is a project export generated with AcMake for the project @THIS_PROJECT_NAME@

# determine if we are integrated or not
get_property(@THIS_PROJECT_NAME@_IS_INTEGRATED GLOBAL PROPERTY @THIS_PROJECT_NAME@_IS_INTEGRATED)
if(@THIS_PROJECT_NAME@_IS_INTEGRATED)
    set(@THIS_PROJECT_NAME@_IS_IMPORTED   NO)
    set(@THIS_PROJECT_NAME@_IS_INTEGRATED YES)
else(@THIS_PROJECT_NAME@_IS_INTEGRATED)
    set(@THIS_PROJECT_NAME@_IS_IMPORTED   YES)
    set(@THIS_PROJECT_NAME@_IS_INTEGRATED NO)
endif(@THIS_PROJECT_NAME@_IS_INTEGRATED)
set(@THIS_PROJECT_NAME@_IS_PROJECT YES)

# set up needed variables
if(@THIS_PROJECT_NAME@_IS_INTEGRATED)
    # in integrated mode we just copy global information
    
    # NOTE: we can use get_globals in integrated mode because
    #       AcMake must have been loaded for us to get here.
    get_globals(@THIS_PROJECT_NAME@ @THIS_PROJECT_NAME@ ${_AC_PROJECT_VARIABLES})

else(@THIS_PROJECT_NAME@_IS_INTEGRATED)
    # in imported mode, we have to template everything

    # load acmake
    find_package(AcMake)

    # templated variables
    set(@THIS_PROJECT_NAME@_NAME           @THIS_PROJECT_NAME@)
    set(@THIS_PROJECT_NAME@_FOUND          YES)
    set(@THIS_PROJECT_NAME@_BUILD_TYPE     @THIS_PROJECT_BUILD_TYPE@)
    set(@THIS_PROJECT_NAME@_CONFIGURATION_TYPES @THIS_PROJECT_CONFIGURATION_TYPES@)
    set(@THIS_PROJECT_NAME@_INSTALL_PREFIX @THIS_PROJECT_INSTALL_PREFIX@)
    set(@THIS_PROJECT_NAME@_DEFINITIONS    @THIS_PROJECT_DEFINITIONS@)
    set(@THIS_PROJECT_NAME@_LIBRARIES      @THIS_PROJECT_LIBRARIES@)
    set(@THIS_PROJECT_NAME@_EXECUTABLES    @THIS_PROJECT_EXECUTABLES@)
    set(@THIS_PROJECT_NAME@_PLUGIN_DIRS    @THIS_PROJECT_PLUGIN_DIRS@)
    set(@THIS_PROJECT_NAME@_PLUGINS        @THIS_PROJECT_PLUGINS@)
    set(@THIS_PROJECT_NAME@_EXTERNS        @THIS_PROJECT_EXTERNS@)
    set(@THIS_PROJECT_NAME@_CUSTOM_SCRIPTS   @THIS_PROJECT_CUSTOM_SCRIPTS@)
    set(@THIS_PROJECT_NAME@_CUSTOM_TEMPLATES @THIS_PROJECT_CUSTOM_TEMPLATES@)
    set(@THIS_PROJECT_NAME@_REQUIRED_PACKAGES  @THIS_PROJECT_REQUIRED_PACKAGES@)
    set(@THIS_PROJECT_NAME@_OPTIONAL_PACKAGES  @THIS_PROJECT_OPTIONAL_PACKAGES@)
    set(@THIS_PROJECT_NAME@_REQUIRED_PKGCONFIG @THIS_PROJECT_REQUIRED_PKGCONFIG@)
    set(@THIS_PROJECT_NAME@_OPTIONAL_PKGCONFIG @THIS_PROJECT_OPTIONAL_PKGCONFIG@)
    set(@THIS_PROJECT_NAME@_BUILD_INCLUDE_DIRS @THIS_PROJECT_BUILD_INCLUDE_DIRS@)

    # determine our current prefix
    get_filename_component(@THIS_PROJECT_NAME@_CMAKE_DIR "${CMAKE_CURRENT_LIST_FILE}" PATH)
    # XXX: clean this mess
    if(WIN32)
        set(_CMAKE_TO_PREFIX "..")
    elseif(OSX)
        set(_CMAKE_TO_PREFIX ".")
    elseif(LINUX)
        set(_CMAKE_TO_PREFIX "../../..")
    endif(WIN32)
    get_filename_component(@THIS_PROJECT_NAME@_PREFIX "${@THIS_PROJECT_NAME@_CMAKE_DIR}/${_CMAKE_TO_PREFIX}" ABSOLUTE)

    set(@THIS_PROJECT_NAME@_RUNTIME_DIR "${@THIS_PROJECT_NAME@_PREFIX}/bin")
    set(@THIS_PROJECT_NAME@_LIBRARY_DIR "${@THIS_PROJECT_NAME@_PREFIX}/lib")
    set(@THIS_PROJECT_NAME@_INCLUDE_DIR "${@THIS_PROJECT_NAME@_PREFIX}/include")

    # since imports can be used both from binary and install trees,
    # we have to find out in which one we are currently lying
    if(EXISTS "${@THIS_PROJECT_NAME@_PREFIX}/CMakeFiles")
        message("@THIS_PROJECT_NAME@ lies in build prefix ${@THIS_PROJECT_NAME@_PREFIX}")
        set(@THIS_PROJECT_NAME@_IMPORTED_FROM_BUILD YES)
    else(EXISTS "${@THIS_PROJECT_NAME@_PREFIX}/CMakeFiles")
        # we are being used from an install tree
        message("@THIS_PROJECT_NAME@ lies in install prefix ${@THIS_PROJECT_NAME@_PREFIX}")
        set(@THIS_PROJECT_NAME@_IMPORTED_FROM_INSTALL YES)
    endif(EXISTS "${@THIS_PROJECT_NAME@_PREFIX}/CMakeFiles")

endif(@THIS_PROJECT_NAME@_IS_INTEGRATED)

# create a list of all linkable targets
# XXX: deliberately incomplete because plugin linkage is not handled yet
set(@THIS_PROJECT_NAME@_LINKABLES ${@THIS_PROJECT_NAME@_LIBRARIES})

# abbreviations
set(@THIS_PROJECT_NAME@_PACKAGES
    ${@THIS_PROJECT_NAME@_REQUIRED_PACKAGES}
    ${@THIS_PROJECT_NAME@_OPTIONAL_PACKAGES}
)

# find out in which directory this file lies
get_filename_component(@THIS_PROJECT_NAME@_MODULE_LOCATION ${CMAKE_CURRENT_LIST_FILE} PATH)

# include custom scripts
if(@THIS_PROJECT_NAME@_IS_INTEGRATED)
    foreach(SCRIPT ${@THIS_PROJECT_NAME@_CUSTOM_SCRIPTS})
        set(_FOUND)
        if(EXISTS ${@THIS_PROJECT_NAME@_BINARY_DIR}/${SCRIPT})
            set(_FOUND YES)
            include(${@THIS_PROJECT_NAME@_BINARY_DIR}/${SCRIPT})
        endif(EXISTS ${@THIS_PROJECT_NAME@_BINARY_DIR}/${SCRIPT})
        if(EXISTS ${@THIS_PROJECT_NAME@_SOURCE_DIR}/${SCRIPT})
            set(_FOUND YES)
            include(${@THIS_PROJECT_NAME@_SOURCE_DIR}/${SCRIPT})
        endif(EXISTS ${@THIS_PROJECT_NAME@_SOURCE_DIR}/${SCRIPT})
        if(NOT _FOUND)
            message(FATAL_ERROR "Could not find custom script ${SCRIPT} in project @THIS_PROJECT_NAME@")
        endif(NOT _FOUND)
        set(_FOUND)
    endforeach(SCRIPT)
else(@THIS_PROJECT_NAME@_IS_INTEGRATED)
    foreach(SCRIPT ${@THIS_PROJECT_NAME@_CUSTOM_SCRIPTS})
        include(${@THIS_PROJECT_NAME@_MODULE_LOCATION}/${SCRIPT})
    endforeach(SCRIPT)
endif(@THIS_PROJECT_NAME@_IS_INTEGRATED)

# make our other cmake files loadable
list(INSERT CMAKE_MODULE_PATH 0 ${@THIS_PROJECT_NAME@_MODULE_LOCATION})

# find external dependencies
include(@THIS_PROJECT_NAME@Dependencies)

# define targets
include(@THIS_PROJECT_NAME@Targets)

# Compute definitions
set(@THIS_PROJECT_NAME@_EXTRA_DEFINITIONS)
foreach(EXTERN ${@THIS_PROJECT_NAME@_EXTERNS})
    list(APPEND @THIS_PROJECT_NAME@_EXTRA_DEFINITIONS ${${EXTERN}_DEFINITIONS})
endforeach(EXTERN ${@THIS_PROJECT_NAME@_EXTERNS})
foreach(PACKAGE ${@THIS_PROJECT_NAME@_PACKAGES})
    if(${PACKAGE}_IS_PROJECT)
        if(${PACKAGE}_DEFINITIONS)
            list(APPEND @THIS_PROJECT_NAME@_EXTRA_DEFINITIONS ${${PACKAGE}_DEFINITIONS})
        endif(${PACKAGE}_DEFINITIONS)
    endif(${PACKAGE}_IS_PROJECT)
endforeach(PACKAGE ${@THIS_PROJECT_NAME@_PACKAGES})

# Compute search paths
set(@THIS_PROJECT_NAME@_EXTERN_INCLUDE_DIRS)
set(@THIS_PROJECT_NAME@_EXTERN_LIBRARY_DIRS)
foreach(LINKABLE ${@THIS_PROJECT_NAME@_LINKABLES})
    foreach(EXTERN ${${LINKABLE}_EXTERNS})
        if(${EXTERN}_LIBRARY_DIRS)
            list(APPEND @THIS_PROJECT_NAME@_EXTERN_LIBRARY_DIRS ${${EXTERN}_LIBRARY_DIRS})
        else(${EXTERN}_LIBRARY_DIRS)
            if(${EXTERN}_LIBRARY_DIR)
                list(APPEND @THIS_PROJECT_NAME@_EXTERN_LIBRARY_DIRS ${${EXTERN}_LIBRARY_DIR})
            endif(${EXTERN}_LIBRARY_DIR)
        endif(${EXTERN}_LIBRARY_DIRS)
        if(${EXTERN}_INCLUDE_DIRS)
            list(APPEND @THIS_PROJECT_NAME@_EXTERN_INCLUDE_DIRS ${${EXTERN}_INCLUDE_DIRS})
        else(${EXTERN}_INCLUDE_DIRS)
            if(${EXTERN}_INCLUDE_DIR)
                list(APPEND @THIS_PROJECT_NAME@_EXTERN_INCLUDE_DIRS ${${EXTERN}_INCLUDE_DIR})
            endif(${EXTERN}_INCLUDE_DIR)
        endif(${EXTERN}_INCLUDE_DIRS)
    endforeach(EXTERN ${${LINKABLE}_EXTERNS})
endforeach(LINKABLE ${@THIS_PROJECT_NAME@_LINKABLES})

# Compute linkage dependencies
foreach(LIBRARY ${@THIS_PROJECT_NAME@_LIBRARIES})
    foreach(DEPEND ${${LIBRARY}_DEPENDS})
        list(APPEND ${LIBRARY}_LIBRARIES ${DEPEND})
        list(APPEND ${LIBRARY}_LIBRARIES ${${DEPEND}_LIBRARIES})
    endforeach(DEPEND ${${LIBRARY}_DEPENDS})
    foreach(EXTERN ${${LIBRARY}_EXTERNS})
        if(NOT ${EXTERN}_IS_PROJECT)
            list(APPEND ${LIBRARY}_LIBRARIES ${${EXTERN}_LIBRARIES})
        endif(NOT ${EXTERN}_IS_PROJECT)
    endforeach(EXTERN ${${LIBRARY}_EXTERNS})
    if(${LIBRARY}_LIBRARIES)
        list(REMOVE_DUPLICATES ${LIBRARY}_LIBRARIES)
    endif(${LIBRARY}_LIBRARIES)
endforeach(LIBRARY ${@THIS_PROJECT_NAME@_LIBRARIES})

# Register libraries as imported
if(@THIS_PROJECT_NAME@_IS_IMPORTED)
    if(@THIS_PROJECT_NAME@_IMPORTED_FROM_BUILD AND @THIS_PROJECT_NAME@_CONFIGURATION_TYPES)
        # register executables as imported
        foreach(EXECUTABLE ${@THIS_PROJECT_NAME@_EXECUTABLES})
            add_executable(${EXECUTABLE} IMPORTED)
            set(LOCATION "${@THIS_PROJECT_NAME@_PREFIX}/${${EXECUTABLE}_LOCATION}")
            get_filename_component(LOCATION_PATH ${LOCATION} PATH)
            get_filename_component(LOCATION_NAME ${LOCATION} NAME)
            foreach(TYPE ${@THIS_PROJECT_NAME@_CONFIGURATION_TYPES})
                set(REAL_LOCATION "${LOCATION_PATH}/${TYPE}/${LOCATION_NAME}")
                if(EXISTS ${REAL_LOCATION})
                    set_target_properties(
                        ${EXECUTABLE}
                        PROPERTIES
                            IMPORTED_LOCATION_${TYPE} ${REAL_LOCATION}
                    )
                endif(EXISTS ${REAL_LOCATION})
            endforeach(TYPE ${@THIS_PROJECT_NAME@_CONFIGURATION_TYPES})
        endforeach(EXECUTABLE ${@THIS_PROJECT_NAME@_EXECUTABLES})

        # register libraries as imported
        foreach(LIBRARY ${@THIS_PROJECT_NAME@_LIBRARIES})
            add_library(${LIBRARY} SHARED IMPORTED)

            set(IMPLIB_LOCATION "${@THIS_PROJECT_NAME@_PREFIX}/${${LIBRARY}_IMPLIB_LOCATION}")
            get_filename_component(IMPLIB_LOCATION_PATH ${IMPLIB_LOCATION} PATH)
            get_filename_component(IMPLIB_LOCATION_NAME ${IMPLIB_LOCATION} NAME)


            set(OBJECT_LOCATION "${@THIS_PROJECT_NAME@_PREFIX}/${${LIBRARY}_OBJECT_LOCATION}")
            get_filename_component(OBJECT_LOCATION_PATH ${OBJECT_LOCATION} PATH)
            get_filename_component(OBJECT_LOCATION_NAME ${OBJECT_LOCATION} NAME)

            foreach(TYPE ${@THIS_PROJECT_NAME@_CONFIGURATION_TYPES})
                set(REAL_IMPLIB_LOCATION "${IMPLIB_LOCATION_PATH}/${TYPE}/${IMPLIB_LOCATION_NAME}")
                set(REAL_OBJECT_LOCATION "${OBJECT_LOCATION_PATH}/${TYPE}/${OBJECT_LOCATION_NAME}")
                if(EXISTS ${REAL_IMPLIB_LOCATION})
                    set_target_properties(
                        ${LIBRARY}
                        PROPERTIES
                            IMPORTED_IMPLIB   "${REAL_IMPLIB_LOCATION}"
                            IMPORTED_LOCATION "${REAL_OBJECT_LOCATION}"
                            IMPORTED_LINK_DEPENDENT_LIBRARIES "${${LIBRARY}_LIBRARIES}"
                    )
                endif(EXISTS ${REAL_IMPLIB_LOCATION})
            endforeach(TYPE ${@THIS_PROJECT_NAME@_CONFIGURATION_TYPES})
        endforeach(LIBRARY @THIS_PROJECT_NAME@_LIBRARIES)
    else(@THIS_PROJECT_NAME@_IMPORTED_FROM_BUILD AND @THIS_PROJECT_NAME@_CONFIGURATION_TYPES)
        # register executables as imported
        foreach(EXECUTABLE ${@THIS_PROJECT_NAME@_EXECUTABLES})
            add_executable(${EXECUTABLE} IMPORTED)
            set_target_properties(
                ${EXECUTABLE}
                PROPERTIES
                    IMPORTED_LOCATION "${@THIS_PROJECT_NAME@_PREFIX}/${${EXECUTABLE}_LOCATION}"
            )
        endforeach(EXECUTABLE ${@THIS_PROJECT_NAME@_EXECUTABLES})

        # register libraries as imported
        foreach(LIBRARY ${@THIS_PROJECT_NAME@_LIBRARIES})
            add_library(${LIBRARY} SHARED IMPORTED)
            set_target_properties(
                ${LIBRARY}
                PROPERTIES
                    IMPORTED_IMPLIB   "${@THIS_PROJECT_NAME@_PREFIX}/${${LIBRARY}_IMPLIB_LOCATION}"
                    IMPORTED_LOCATION "${@THIS_PROJECT_NAME@_PREFIX}/${${LIBRARY}_OBJECT_LOCATION}"
                    IMPORTED_LINK_DEPENDENT_LIBRARIES "${${LIBRARY}_LIBRARIES}"
            )
        endforeach(LIBRARY @THIS_PROJECT_NAME@_LIBRARIES)
    endif(@THIS_PROJECT_NAME@_IMPORTED_FROM_BUILD AND @THIS_PROJECT_NAME@_CONFIGURATION_TYPES)
endif(@THIS_PROJECT_NAME@_IS_IMPORTED)

# Export definitions
set(@THIS_PROJECT_NAME@_DEFINITIONS ${@THIS_PROJECT_NAME@_DEFINITIONS} ${@THIS_PROJECT_NAME@_EXTRA_DEFINITIONS})

# Export search paths
set(@THIS_PROJECT_NAME@_INCLUDE_DIRS ${@THIS_PROJECT_NAME@_INCLUDE_DIR})
set(@THIS_PROJECT_NAME@_LIBRARY_DIRS ${@THIS_PROJECT_NAME@_LIBRARY_DIR})
if(@THIS_PROJECT_NAME@_IS_IMPORTED)
    list(APPEND @THIS_PROJECT_NAME@_INCLUDE_DIRS ${@THIS_PROJECT_NAME@_BUILD_INCLUDE_DIRS})
    list(APPEND @THIS_PROJECT_NAME@_INCLUDE_DIRS ${@THIS_PROJECT_NAME@_EXTERN_INCLUDE_DIRS})
    list(APPEND @THIS_PROJECT_NAME@_LIBRARY_DIRS ${@THIS_PROJECT_NAME@_EXTERN_LIBRARY_DIRS})
endif(@THIS_PROJECT_NAME@_IS_IMPORTED)

# handle requirements and error messages
include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(
    @THIS_PROJECT_NAME@ DEFAULT_MSG
    @THIS_PROJECT_NAME@_LIBRARIES @THIS_PROJECT_NAME@_INCLUDE_DIR
)
