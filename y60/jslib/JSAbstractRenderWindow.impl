/* __ ___ ____ _____ ______ _______ ________ _______ ______ _____ ____ ___ __
//
// Copyright (C) 1993-2008, ART+COM AG Berlin, Germany <www.artcom.de>
//
// These coded instructions, statements, and computer programs contain
// proprietary information of ART+COM AG Berlin, and are copy protected
// by law. They may be used, modified and redistributed under the terms
// of GNU General Public License referenced below.
//
// Alternative licensing without the obligations of the GPL is
// available upon request.
//
// GPL v3 Licensing:
//
// This file is part of the ART+COM Y60 Platform.
//
// ART+COM Y60 is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// ART+COM Y60 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with ART+COM Y60.  If not, see <http://www.gnu.org/licenses/>.
// __ ___ ____ _____ ______ _______ ________ _______ ______ _____ ____ ___ __
//
// Description: TODO
//
// Last Review: NEVER, NOONE
//
//  review status report: (perfect, ok, fair, poor, disaster, notapplicable, unknown)
//    usefullness            : unknown
//    formatting             : unknown
//    documentation          : unknown
//    test coverage          : unknown
//    names                  : unknown
//    style guide conformance: unknown
//    technical soundness    : unknown
//    dead code              : unknown
//    readability            : unknown
//    understandabilty       : unknown
//    interfaces             : unknown
//    confidence             : unknown
//    integration            : unknown
//    dependencies           : unknown
//    cheesyness             : unknown
//
//    overall review status  : unknown
//
//    recommendations:
//       - unknown
// __ ___ ____ _____ ______ _______ ________ _______ ______ _____ ____ ___ __
*/

#include "JSAbstractRenderWindow.h"
#include "JSRenderer.h"
#include "JSintersection_functions.h"
#include <y60/jsbase/IScriptablePlugin.h>
#include <y60/jsbase/JSScriptablePlugin.h>
#include <y60/scene/Viewport.h>
#include "JSScene.h"
#include "IRendererExtension.h"

#include <y60/glutil/ScopedGLContext.h>

#include <asl/base/string_functions.h>
#include <asl/base/os_functions.h>

namespace jslib {

template<class DERIVED>
JSBool JSAbstractRenderWindow<DERIVED>::setTimeout(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Sets a javascript line to be executed after a certain time. When a JSObject is given the JSCommand (e.g. a function name) is called on that object.");
    DOC_PARAM("theJavaScriptCommand", "", DOC_TYPE_STRING);
    DOC_PARAM("theMilliseconds", "", DOC_TYPE_FLOAT);
    DOC_PARAM_OPT("theJSObjectToCall", "", DOC_TYPE_OBJECT, "");
    DOC_RVAL("theTimeoutId", DOC_TYPE_INTEGER);
    DOC_END;

    if (argc == 2 || argc == 3) {
        DERIVED * mySelf;
        convertFrom(cx, OBJECT_TO_JSVAL(obj), mySelf);

        std::string myCallback;
        if (!convertFrom(cx, argv[0], myCallback)) {
            return JS_FALSE;
        }
        float myMillisec;
        if (!convertFrom(cx, argv[1], myMillisec)) {
            return JS_FALSE;
        }

        if (argc == 3) {
            JSObject * myObjectToCall;
            if (JS_ValueToObject(cx, argv[2], &myObjectToCall)) {
                long myRetVal = mySelf->setTimeout(myCallback, myMillisec, myObjectToCall);
                *rval = as_jsval(cx, myRetVal);
                 return JS_TRUE;
            }
        } else {
            long myRetVal = mySelf->setTimeout(myCallback, myMillisec, 0);
            *rval = as_jsval(cx, myRetVal);
             return JS_TRUE;
        }
    }
    return JS_FALSE;
}

template<class DERIVED>
JSBool JSAbstractRenderWindow<DERIVED>::setInterval(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Sets a javascript line to be executed in a certain interval until clearInterval() is called. When a JSObject is given the JSCommand (e.g. a function name) is called on that object.");
    DOC_PARAM("theJavaScriptCommand", "", DOC_TYPE_STRING);
    DOC_PARAM("theMilliseconds", "", DOC_TYPE_FLOAT);
    DOC_PARAM_OPT("theJSObjectToCall", "", DOC_TYPE_OBJECT, "");
    DOC_RVAL("theTimeoutId", DOC_TYPE_INTEGER);
    DOC_END;
    if (argc == 2 || argc == 3) {
        DERIVED * mySelf;
        convertFrom(cx, OBJECT_TO_JSVAL(obj), mySelf);

        std::string myCallback;
        if (!convertFrom(cx, argv[0], myCallback)) {
            return JS_FALSE;
        }
        float myMillisec;
        if (!convertFrom(cx, argv[1], myMillisec)) {
            return JS_FALSE;
        }

        if (argc == 3) {
            JSObject * myObjectToCall;
            if (JS_ValueToObject(cx, argv[2], &myObjectToCall)) {
                long myRetVal = mySelf->setInterval(myCallback, myMillisec, myObjectToCall);
                *rval = as_jsval(cx, myRetVal);
                 return JS_TRUE;
            }
        } else {
            long myRetVal = mySelf->setInterval(myCallback, myMillisec, 0);
            *rval = as_jsval(cx, myRetVal);
             return JS_TRUE;
        }
    }
    return JS_FALSE;
}

template<class DERIVED>
JSBool JSAbstractRenderWindow<DERIVED>::clearTimeout(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Stops a timeout from beeing executed");
    DOC_PARAM("theTimeoutId", "", DOC_TYPE_INTEGER);
    DOC_END;
    typedef void (DERIVED::*MyMethod)(long);
    return Method<DERIVED>::call((MyMethod)&DERIVED::clearTimeout,cx,obj,argc,argv,rval);
}

template<class DERIVED>
JSBool JSAbstractRenderWindow<DERIVED>::clearInterval(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Stops an interval from beeing executed");
    DOC_PARAM("theTimeoutId", "", DOC_TYPE_INTEGER);
    DOC_END;
    typedef void (DERIVED::*MyMethod)(long);
    return Method<DERIVED>::call((MyMethod)&DERIVED::clearInterval,cx,obj,argc,argv,rval);
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::saveBuffer(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Saves a screenshot to a given file");
    DOC_PARAM("theFilename", "Filename to save to", DOC_TYPE_STRING);
    DOC_PARAM_OPT("theComponents", "components to save default 3 (RGB)", DOC_TYPE_INTEGER, 3);
    DOC_PARAM_OPT("theCompressionOrQualityLevel", "compression level in percent, for png: 100=highest compression, for jpeg: 100=best quality", DOC_TYPE_INTEGER, 0);
    DOC_END;
    try {
        ensureParamCount(argc, 1, 3);
        DERIVED * mySelf;
        convertFrom(cx, OBJECT_TO_JSVAL(obj), mySelf);

        std::string myFilename;
        if (!convertFrom(cx, argv[0], myFilename)) {
            return JS_FALSE;
        }
        if (argc == 1) {
            mySelf->saveBuffer(myFilename);
             return JS_TRUE;
        } else if (argc == 2) {
            unsigned int myComponents;
            if (!convertFrom(cx, argv[1], myComponents)) {
                return JS_FALSE;
            }
            mySelf->saveBuffer(myFilename, myComponents);
             return JS_TRUE;
        } else {
            unsigned int myComponents;
            if (!convertFrom(cx, argv[1], myComponents)) {
                return JS_FALSE;
            }
            int myCompressionOrQualityLevel;
            if (!convertFrom(cx, argv[2], myCompressionOrQualityLevel)) {
                return JS_FALSE;
            }
            mySelf->saveBuffer(myFilename, myComponents, myCompressionOrQualityLevel);
             return JS_TRUE;
        }
        return JS_FALSE;
    } HANDLE_CPP_EXCEPTION;
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::copyBufferToTexture(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Copy framebuffer to Texture (and optionally to Image raster)");
    DOC_PARAM("theTexture", "Texture node", DOC_TYPE_NODE);
    DOC_PARAM("theOffset", "Read offset in framebuffer", DOC_TYPE_VECTOR2I);
    DOC_PARAM("theCopyToImageFlag", "Copy to image instead of direcly to texture", DOC_TYPE_BOOLEAN);
    DOC_END;
    typedef void (DERIVED::*MyMethod)(dom::NodePtr &, const asl::Vector2i &, bool);
    return Method<DERIVED>::call((MyMethod)&DERIVED::copyBufferToTexture,cx,obj,argc,argv,rval);
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::getRenderer(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Returns the renderer currently attached to this window");
    DOC_RVAL("theRenderer", DOC_TYPE_OBJECT);
    DOC_END;
    try {
        DERIVED * mySelf;
        convertFrom(cx, OBJECT_TO_JSVAL(obj), mySelf);
        y60::RendererPtr myRetVal = mySelf->getRenderer();
        *rval = as_jsval(cx, myRetVal);
        return JS_TRUE;
    } HANDLE_CPP_EXCEPTION;
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::setSceneAndCanvas(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("set the scene and canvas to render");
    DOC_PARAM("theScene", "Scene to render", DOC_TYPE_OBJECT);
    DOC_PARAM("theCanvas", "Canvas node to render to. If omitted, use the first canvas", DOC_TYPE_OBJECT);
    DOC_RVAL("bSuccess", DOC_TYPE_OBJECT);
    DOC_END;
    try {
        DERIVED * mySelf;
        convertFrom(cx, OBJECT_TO_JSVAL(obj), mySelf);
        if (argc == 1 || (argc == 2 && JSVAL_IS_VOID(argv[1]))) {
            convertFrom(cx, OBJECT_TO_JSVAL(obj), mySelf);
            y60::ScenePtr myScene;
            if (!convertFrom(cx, argv[0], myScene)) {
                return JS_FALSE;
            }
            bool myResult = mySelf->setSceneAndCanvas(myScene);
            *rval = as_jsval(cx, myResult);
            return JS_TRUE;
            // XXX
            //typedef bool (NATIVE::*MyMethod)(const y60::ScenePtr & theScene);
            //return Method<NATIVE>::call((MyMethod)&NATIVE::setSceneAndCanvas,cx,obj,1,argv,rval);
        } else {// argc == 2
            convertFrom(cx, OBJECT_TO_JSVAL(obj), mySelf);
            y60::ScenePtr myScene;
            if (!convertFrom(cx, argv[0], myScene)) {
                return JS_FALSE;
            }
            dom::NodePtr myCanvasNode;
            if (!convertFrom(cx, argv[1], myCanvasNode)) {
                return JS_FALSE;
            }
            bool myResult = mySelf->setSceneAndCanvas(myScene, myCanvasNode);
            *rval = as_jsval(cx, myResult);
            return JS_TRUE;
            // XXX
            //typedef bool (NATIVE::*MyMethod)(const y60::ScenePtr & theScene, const dom::NodePtr & theCanvas);
            //return Method<NATIVE>::call((MyMethod)&NATIVE::setSceneAndCanvas,cx,obj,argc,argv,rval);
        }
    } HANDLE_CPP_EXCEPTION;
}
template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::hasCap(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Checks if the renderer has a certain capability." \
              "Possible Capability constants are static properties of the Renderer object");
    DOC_PARAM("theCapability", "Capability to test for", DOC_TYPE_ENUMERATION);
    DOC_RVAL("theResult", DOC_TYPE_BOOLEAN);
    DOC_END;
    typedef bool (DERIVED::*MyMethod)(unsigned);
    return Method<DERIVED>::call((MyMethod)&DERIVED::hasCap,cx,obj,argc,argv,rval);
}
template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::hasCapAsString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Checks if the renderer has a certain capability." \
              "Use OpenGL hasCap command is called with the capability string.");
    DOC_PARAM("theCapability", "Capability to test for", DOC_TYPE_STRING);
    DOC_RVAL("theResult", DOC_TYPE_BOOLEAN);
    DOC_END;
    typedef bool (DERIVED::*MyMethod)(const std::string &);
    return Method<DERIVED>::call((MyMethod)&DERIVED::hasCapAsString,cx,obj,argc,argv,rval);
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::printStatistics(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Prints render statistics and profiling information to the console");
    DOC_END;
    typedef void (DERIVED::*MyMethod)(void);
    return Method<DERIVED>::call((MyMethod)&DERIVED::printStatistics,cx,obj,argc,argv,rval);
}
template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::getImagePixel(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Returns the color of a pixel at position x, y of an image");
    DOC_PARAM("theImageNode", "", DOC_TYPE_NODE);
    DOC_PARAM("theXPosition", "", DOC_TYPE_INTEGER);
    DOC_PARAM("theYPosition", "", DOC_TYPE_INTEGER);
    DOC_RVAL("theColor", DOC_TYPE_VECTOR4F);
    DOC_END;
    typedef asl::Vector4i (DERIVED::*MyMethod)(dom::NodePtr, unsigned long, unsigned long);
    return Method<DERIVED>::call((MyMethod)&DERIVED::getImagePixel,cx,obj,argc,argv,rval);
}
template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::setImagePixel(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Sets the color of a pixel at position x, y in an image");
    DOC_PARAM("theImageNode", "", DOC_TYPE_NODE);
    DOC_PARAM("theXPosition", "", DOC_TYPE_INTEGER);
    DOC_PARAM("theYPosition", "", DOC_TYPE_INTEGER);
    DOC_PARAM("theColor", "", DOC_TYPE_VECTOR4F);
    DOC_RVAL("theSuccess", DOC_TYPE_BOOLEAN);
    DOC_END;
    typedef bool (DERIVED::*MyMethod)(dom::NodePtr, unsigned long, unsigned long, const asl::Vector4i &);
    return Method<DERIVED>::call((MyMethod)&DERIVED::setImagePixel,cx,obj,argc,argv,rval);
}
template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::getPixel(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Returns the pixel at position x, y of a GL buffer (see man glReadPixels)");
    DOC_PARAM("theXPosition", "", DOC_TYPE_INTEGER);
    DOC_PARAM("theYPosition", "", DOC_TYPE_INTEGER);
    DOC_PARAM("theFormat", "a GL Format type GL_RED, GL_BLUE, GL_DEPTH_COMPONENT, etc.", DOC_TYPE_ENUMERATION);
    DOC_PARAM("theType", "", DOC_TYPE_ENUMERATION);
    DOC_RVAL("thePixelValue", DOC_TYPE_VECTOR4F);
    DOC_END;
    try {
        ensureParamCount(argc, 4);
        DERIVED * mySelf;
        convertFrom(cx, OBJECT_TO_JSVAL(obj), mySelf);
        int myXPos;
        convertFrom(cx, argv[0], myXPos);
        int myYPos;
        convertFrom(cx, argv[1], myYPos);
        GLenum myFormat;
        convertFrom(cx, argv[2], myFormat);
        GLenum myType;
        convertFrom(cx, argv[3], myType);
        if (myXPos < 0 || myYPos < 0 || myXPos >= mySelf->getWidth() ||
            myYPos >= mySelf->getHeight())
        {
            *rval = JSVAL_NULL;
            return JS_TRUE;
        }
        switch (myType) {
            case GL_UNSIGNED_BYTE:
                {
                    asl::Unsigned8 myPixel;
                    mySelf->getPixel(myXPos, myYPos, myFormat, myPixel);
                    *rval = as_jsval(cx, myPixel);
                    break;
                }
            case GL_FLOAT:
                {
                    float myPixel;
                    mySelf->getPixel(myXPos, myYPos, myFormat, myPixel);
                    *rval = as_jsval(cx, myPixel);
                    break;
                }
            default:
                JS_ReportError(cx,"readPixel: Format not supported");
                return JS_FALSE;
        }
        return JS_TRUE;
    } HANDLE_CPP_EXCEPTION;
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::performRequest(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Performs an http request");
    DOC_PARAM("theRequest", "", DOC_TYPE_OBJECT);
    DOC_END;
    if (argc == 1) {
        if (!JSRequestWrapper::matchesClassOf(cx, argv[0])) {
            JS_ReportError(cx,"JSRenderWindow::performRequest: bad argument type #0");
            return JS_FALSE;
        }
        typedef void (DERIVED::*MyMethod)(const JSRequestPtr &);
        return Method<DERIVED>::call((MyMethod)&DERIVED::performRequest,cx,obj,argc,argv,rval);
    }
    JS_ReportError(cx,"JSRenderWindow::performRequest: bad number of arguments, 1 expected");
    return JS_FALSE;
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::addExtension(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Adds a renderextension object to the window");
    DOC_PARAM("theRenderExtension", "", DOC_TYPE_OBJECT);
    DOC_END;
    try {
        if (argc == 1) {
            // [DS] This is the place where IScriptablePlugin and IRenderExtension are intermingled.
            // thats why you can't implement a RenderExtension without implementing a ScriptablePlugin
            // TODO: fix this!
            IScriptablePluginPtr myScriptablePlugin;
            if (!convertFrom(cx, argv[0], myScriptablePlugin)) {
                JS_ReportError(cx,"JSRenderWindow::addExtension: parameter 1 must be a plugin");
                return JS_FALSE;
            }

            y60::IRendererExtensionPtr myExtension = dynamic_cast_Ptr<y60::IRendererExtension>(myScriptablePlugin);
            if (!myExtension) {
                JS_ReportError(cx, "Plug-In does not implement y60::IRendererExtension");
                return JS_FALSE;
            }
            jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).addExtension(myExtension);
            jslib::JSClassTraits<DERIVED>::closeNativeRef(cx,obj);
            return JS_TRUE;
        }
        JS_ReportError(cx,"JSRenderWindow::addExtension: bad number of arguments, 1 expected");
        return JS_FALSE;
    } HANDLE_CPP_EXCEPTION;
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::renderText(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Renders a text onto the screen");
    DOC_PARAM("thePosition in Pixel", "", DOC_TYPE_VECTOR2F);
    DOC_PARAM("theTextString", "", DOC_TYPE_STRING);
    DOC_PARAM_OPT("theStyleObject", "A textstyle object", DOC_TYPE_OBJECT, "");    
    DOC_PARAM_OPT("theFontName", "An OpenGL compiled font name", DOC_TYPE_STRING, "Screen15");
    DOC_PARAM_OPT("theViewport", "", DOC_TYPE_OBJECT, "");
    DOC_END;
    try {
    
        ensureParamCount(argc, 2, 5);

        y60::TextStyle myTextStyle;
        dom::NodePtr myStyleNode;

        asl::Vector2f thePixelPosition;
        if (!convertFrom(cx, argv[0], thePixelPosition)) {
            JS_ReportError(cx,"JSRenderWindow::renderText: parameter 1 must be a Vector2f");
            return JS_FALSE;
        }

        std::string theString;
        if (!convertFrom(cx, argv[1], theString)) {
            JS_ReportError(cx,"JSRenderWindow::renderText: parameter 2 must be a string");
            return JS_FALSE;
        }
        if (argc >= 3) {
            if (!convertFrom(cx,argv[2], myStyleNode)) {
                JS_ReportError(cx,"JSRenderWindow::renderText: parameter 3 must be a style node");
                return JS_FALSE;
            }
            myTextStyle = y60::TextStyle(myStyleNode);
        }

        if (argc == 3) {

            jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).setTextStyle(myTextStyle);
            jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).renderText(thePixelPosition, theString);
            jslib::JSClassTraits<DERIVED>::closeNativeRef(cx,obj);
        } else {
            std::string theFont;
            if (!convertFrom(cx, argv[3], theFont)) {
                JS_ReportError(cx,"JSRenderWindow::renderText: parameter 4 must be a fontname");
                return JS_FALSE;
            }
            
            if (argc >4) {
                dom::NodePtr theViewportNode;
                if (!convertFrom(cx,argv[4],theViewportNode)) {
                    JS_ReportError(cx,"JSRenderWindow::renderText: parameter 5 must be an viewport node");
                    return JS_FALSE;
                }
                jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).setTextStyle(myTextStyle);
                jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).renderText(thePixelPosition, theString, theFont, theViewportNode->getFacade<y60::Viewport>());
            } else {
            
                jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).setTextStyle(myTextStyle);
                jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).renderText(thePixelPosition, theString, theFont);
            }
            jslib::JSClassTraits<DERIVED>::closeNativeRef(cx,obj);
        }

        return JS_TRUE;
    } HANDLE_CPP_EXCEPTION;
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::renderTextAsImage(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Renders a text into a target image node");
    DOC_PARAM("theImageNode", "A X60 target imagenode", DOC_TYPE_NODE);
    DOC_PARAM("theTextString", "The text to render", DOC_TYPE_STRING);
    DOC_PARAM("theFontName", "The font name", DOC_TYPE_STRING);
    DOC_PARAM_OPT("theStyleObject", "A textstyle object", DOC_TYPE_OBJECT, "");
    DOC_PARAM_OPT("theTextBoxWidth", "The textbox width, 0 to fit text", DOC_TYPE_INTEGER, 0);
    DOC_PARAM_OPT("theTextBoxHeight", "The textbox height, 0 to fit text", DOC_TYPE_INTEGER, 0);
    DOC_PARAM_OPT("theCursorPos", "where to place the text cursor. default is (0,0)", DOC_TYPE_VECTOR2I, asl::Vector2i(0,0));
    DOC_RVAL("theFilledTextBoxSize", DOC_TYPE_VECTOR2I);
    DOC_END;

    ensureParamCount(argc, 3, 7);
    dom::NodePtr theImageNode;
    std::string theTextString;
    std::string theFontName;
    unsigned int theTextBoxWidth;
    unsigned int theTextBoxHeight;
    asl::Vector2i theCursorPos;
    asl::Vector2i myBoxSize;
    y60::TextStyle myTextStyle;
    
    if (argc >= 1) {
        if (!convertFrom(cx,argv[0],theImageNode)) {
            JS_ReportError(cx,"JSRenderWindow::renderTextAsImage: parameter 1 must be an image node");
            return JS_FALSE;
        }
    }
    if (argc >= 2) {
        if (!convertFrom(cx,argv[1],theTextString)) {
            JS_ReportError(cx,"JSRenderWindow::renderTextAsImage: parameter 2 must be a string");
            return JS_FALSE;
        }
    }
    if (argc >= 3) {
        if (!convertFrom(cx,argv[2],theFontName)) {
            JS_ReportError(cx,"JSRenderWindow::renderTextAsImage: parameter 3 must be a string");
            return JS_FALSE;
        }
    }
    if (argc >= 4) {
        dom::NodePtr myStyleNode;
        if (!convertFrom(cx,argv[3], myStyleNode)) {
            JS_ReportError(cx,"JSRenderWindow::renderTextAsImage: parameter 4 must be a style node");
            return JS_FALSE;
        }
        myTextStyle = y60::TextStyle(myStyleNode);
    }
    if (argc >= 5) {
        if (!convertFrom(cx,argv[4],theTextBoxWidth)) {
            JS_ReportError(cx,"JSRenderWindow::renderTextAsImage: parameter 5 must be an int");
            return JS_FALSE;
        }
    }
    if (argc >= 6) {
        if (!convertFrom(cx,argv[5],theTextBoxHeight)) {
            JS_ReportError(cx,"JSRenderWindow::renderTextAsImage: parameter 6 must be an int");
            return JS_FALSE;
        }
    }
    if (argc >= 7) {
        if (!convertFrom(cx,argv[6],theCursorPos)) {
            JS_ReportError(cx,"JSRenderWindow::renderTextAsImage: parameter 7 must be a vector2i ");
            return JS_FALSE;
        }
    }

    try {
    switch (argc) {
        case 3:
        case 4:
            jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).setTextStyle(myTextStyle);
            myBoxSize = jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).
                renderTextAsImage(theImageNode, theTextString, theFontName);
            jslib::JSClassTraits<DERIVED>::closeNativeRef(cx,obj);
            break;
        case 5:
            jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).setTextStyle(myTextStyle);
            myBoxSize = jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).
                renderTextAsImage(theImageNode, theTextString, theFontName, theTextBoxWidth);
            jslib::JSClassTraits<DERIVED>::closeNativeRef(cx,obj);
            break;
        case 6:
            jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).setTextStyle(myTextStyle);
            myBoxSize = jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).
                renderTextAsImage(theImageNode, theTextString, theFontName, theTextBoxWidth, theTextBoxHeight);
            jslib::JSClassTraits<DERIVED>::closeNativeRef(cx,obj);
            break;
        case 7:
            jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).setTextStyle(myTextStyle);
            myBoxSize = jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).
                renderTextAsImage(theImageNode, theTextString, theFontName, theTextBoxWidth, theTextBoxHeight, theCursorPos);
            jslib::JSClassTraits<DERIVED>::closeNativeRef(cx,obj);
            break;
        default:
            JS_ReportError(cx,"JSRenderWindow::renderTextAsImage: wrong number of arguments, 3 to 7 expected ");
            return JS_FALSE;
    }
    *rval = as_jsval(cx, myBoxSize);
    return JS_TRUE;
    } HANDLE_CPP_EXCEPTION;
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::getTextGlyphPositions(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Gets the last rendered glyph position in x and y coordinates. Can be used after calling renderTextAsImage to be used in subsequent calls.");
    DOC_RVAL("thePositions", DOC_TYPE_VECTOR2I);
    DOC_END;
    try {
        const std::vector<asl::Vector2i> & myPos = jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).getTextGlyphPositions();
        *rval = as_jsval(cx, myPos);
        jslib::JSClassTraits<DERIVED>::closeNativeRef(cx,obj);
        return JS_TRUE;
    } HANDLE_CPP_EXCEPTION;
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::getTextCursorPosition(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Gets the text cursor position. Can be used after calling renderTextAsImage to be used in subsequent calls.");
    DOC_RVAL("thePosition", DOC_TYPE_VECTOR2I);
    DOC_END;
    try {
        const asl::Vector2i & myPos = jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).getTextCursorPosition();
        *rval = as_jsval(cx, myPos);
        jslib::JSClassTraits<DERIVED>::closeNativeRef(cx,obj);
        return JS_TRUE;
    } HANDLE_CPP_EXCEPTION;
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::getTextLineWidths(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Gets the text width for every line. Can be used after calling renderTextAsImage to be used in subsequent calls.");
    DOC_RVAL("theLineWidths", DOC_TYPE_ARRAY);
    DOC_END;
    try {
        const std::vector<unsigned int> & myWidths = jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).getLineWidths();
        *rval = as_jsval(cx, myWidths);
        jslib::JSClassTraits<DERIVED>::closeNativeRef(cx,obj);
        return JS_TRUE;
    } HANDLE_CPP_EXCEPTION;
}


template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::getTextMaxWidth(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Gets the maximal text width. Can be used after calling renderTextAsImage to be used in subsequent calls.");
    DOC_RVAL("theMaxWidth", DOC_TYPE_INTEGER);
    DOC_END;
    try {
        const unsigned int & myWidth = jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).getMaxWidth();
        *rval = as_jsval(cx, myWidth);
        jslib::JSClassTraits<DERIVED>::closeNativeRef(cx,obj);
        return JS_TRUE;
    } HANDLE_CPP_EXCEPTION;
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::getFontMetrics(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Gets metrics of the given font");
    DOC_PARAM("theFont", "Font name", DOC_TYPE_STRING);
    DOC_RVAL("{height,ascent,descent,lineskip}", DOC_TYPE_OBJECT);
    DOC_END;
    if (argc == 1) {
        std::string myFontName;
        if (!convertFrom(cx,argv[0],myFontName)) {
            JS_ReportError(cx,"JSRenderWindow::getFontMetrics: parameter 0 must be a string");
            return JS_FALSE;
        }

        int myFontHeight, myFontAscent, myFontDescent, myFontLineSkip;
        jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).getFontMetrics(myFontName, myFontHeight, myFontAscent, myFontDescent, myFontLineSkip);
        jslib::JSClassTraits<DERIVED>::closeNativeRef(cx,obj);

        JSObject * myReturnObject = JS_NewArrayObject(cx, 0, NULL);
        *rval = OBJECT_TO_JSVAL(myReturnObject);
        if (!JS_DefineProperty(cx, myReturnObject, "height", as_jsval(cx, myFontHeight), 0,0, JSPROP_ENUMERATE)) return JS_FALSE;
        if (!JS_DefineProperty(cx, myReturnObject, "ascent", as_jsval(cx, myFontAscent), 0,0, JSPROP_ENUMERATE)) return JS_FALSE;
        if (!JS_DefineProperty(cx, myReturnObject, "descent", as_jsval(cx, myFontDescent), 0,0, JSPROP_ENUMERATE)) return JS_FALSE;
        if (!JS_DefineProperty(cx, myReturnObject, "lineskip", as_jsval(cx, myFontLineSkip), 0,0, JSPROP_ENUMERATE)) return JS_FALSE;

        return JS_TRUE;
    }
    JS_ReportError(cx,"JSRenderWindow::getFontMetrics: bad number of arguments, 1 expected");
    return JS_FALSE;
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::getGlyphMetrics(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Gets metrics of a glyph of the given font");
    DOC_PARAM("theFont", "Font name", DOC_TYPE_STRING);
    DOC_PARAM("theGlyph", "Glyph", DOC_TYPE_STRING);
    DOC_RVAL("{min,max,advance}", DOC_TYPE_OBJECT);
    DOC_END;
    if (argc == 2) {
        std::string myFontName;
        if (!convertFrom(cx,argv[0],myFontName)) {
            JS_ReportError(cx,"JSRenderWindow::getGlyphMetrics: parameter 0 must be a string");
            return JS_FALSE;
        }
        std::string myCharacter;
        if (!convertFrom(cx,argv[1],myCharacter)) {
            JS_ReportError(cx,"JSRenderWindow::getGlyphMetrics: parameter 1 must be a string");
            return JS_FALSE;
        }

        asl::Box2f myGlyphBox;
        double myAdvance;
#if 1
        jslib::JSClassTraits<DERIVED>::openNativeRef(cx, obj).getGlyphMetrics(myFontName, myCharacter, myGlyphBox, myAdvance);
        jslib::JSClassTraits<DERIVED>::closeNativeRef(cx,obj);
#else
        jslib::JSClassTraits<DERIVED>::ScopedNativeRef myObj(cx, obj);
        myObj.getNative().getGlyphMetrics(myFontName, myCharacter, myGlyphBox, myAdvance);
#endif

        JSObject * myReturnObject = JS_NewArrayObject(cx, 0, NULL);
        *rval = OBJECT_TO_JSVAL(myReturnObject);
        if (!JS_DefineProperty(cx, myReturnObject, "min",    as_jsval(cx, myGlyphBox.getMin()), 0,0, JSPROP_ENUMERATE)) return JS_FALSE;
        if (!JS_DefineProperty(cx, myReturnObject, "max",    as_jsval(cx, myGlyphBox.getMax()), 0,0, JSPROP_ENUMERATE)) return JS_FALSE;
        if (!JS_DefineProperty(cx, myReturnObject, "advance", as_jsval(cx, myAdvance), 0,0, JSPROP_ENUMERATE)) return JS_FALSE;

        return JS_TRUE;
    }
    JS_ReportError(cx,"JSRenderWindow::getGlyphMetrics: bad number of arguments, 2 expected");
    return JS_FALSE;
}
template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::getKerning(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Get kerning for two glyphs of the given font");
    DOC_PARAM("theFont", "Font name", DOC_TYPE_STRING);
    DOC_PARAM("theGlyph0", "First glyph", DOC_TYPE_STRING);
    DOC_PARAM("theGlyph1", "Second glyph", DOC_TYPE_STRING);
    DOC_RVAL("Kerning", DOC_TYPE_FLOAT);
    DOC_END;
    typedef double (DERIVED::*MyMethod)(const std::string &, const std::string &, const std::string &);
    return Method<DERIVED>::call((MyMethod)&DERIVED::getKerning,cx,obj,argc,argv,rval);
}
template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::hasGlyph(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Is a glyph part of the given font");
    DOC_PARAM("theFont", "Font name", DOC_TYPE_STRING);
    DOC_PARAM("theGlyph", "The glyph", DOC_TYPE_STRING);
    DOC_RVAL("Result (-1 ->no, 0->o.k.", DOC_TYPE_FLOAT);
    DOC_END;
    typedef bool (DERIVED::*MyMethod)(const std::string &, const std::string &);
    return Method<DERIVED>::call((MyMethod)&DERIVED::hasGlyph,cx,obj,argc,argv,rval);
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::playClip(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Plays an animation clip within character at a given time");
    DOC_PARAM("thePlayTime", "", DOC_TYPE_FLOAT);
    DOC_PARAM("theCharacterName", "", DOC_TYPE_STRING);
    DOC_PARAM("theClipName", "", DOC_TYPE_STRING);
    DOC_END;
    typedef void (DERIVED::*MyMethod)(float, const std::string &, const std::string &);
    return Method<DERIVED>::call((MyMethod)&DERIVED::playClip,cx,obj,argc,argv,rval);
}
template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::setClipLoops(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Sets the number of loops of a clip within character");
    DOC_PARAM("theCharacterName", "", DOC_TYPE_STRING);
    DOC_PARAM("theClipName", "", DOC_TYPE_STRING);
    DOC_PARAM("theNumberOfLoops", "", DOC_TYPE_INTEGER);
    DOC_END;
    typedef void (DERIVED::*MyMethod)(const std::string &, const std::string &, unsigned);
    return Method<DERIVED>::call((MyMethod)&DERIVED::setClipLoops,cx,obj,argc,argv,rval);
}
template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::setClipForwardDirection(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Sets the direction of a clip within character");
    DOC_PARAM("theCharacterName", "", DOC_TYPE_STRING);
    DOC_PARAM("theClipName", "", DOC_TYPE_STRING);
    DOC_PARAM("theDirection", "", DOC_TYPE_BOOLEAN);
    DOC_END;
    typedef void (DERIVED::*MyMethod)(const std::string &, const std::string &, bool);
    return Method<DERIVED>::call((MyMethod)&DERIVED::setClipForwardDirection,cx,obj,argc,argv,rval);
}
template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::getLoops(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Returns the number of loops of a clip within character");
    DOC_PARAM("theCharacterName", "", DOC_TYPE_STRING);
    DOC_PARAM("theClipName", "", DOC_TYPE_STRING);
    DOC_RVAL("numberOfLoops", DOC_TYPE_INTEGER);
    DOC_END;
    typedef unsigned (DERIVED::*MyMethod)(const std::string &, const std::string &);
    return Method<DERIVED>::call((MyMethod)&DERIVED::getLoops,cx,obj,argc,argv,rval);
}
template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::runAnimations(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Runs all global animations with a given time.");
    DOC_PARAM("theTime", "", DOC_TYPE_FLOAT);
    DOC_END;
    typedef void (DERIVED::*MyMethod)(float);
    return Method<DERIVED>::call((MyMethod)&DERIVED::runAnimations,cx,obj,argc,argv,rval);
}
template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::isClipActive(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Returns if a clip within character with a given name is active");
    DOC_PARAM("theCharacterName", "", DOC_TYPE_STRING);
    DOC_PARAM("theClipName", "", DOC_TYPE_STRING);
    DOC_RVAL("isActive", DOC_TYPE_BOOLEAN);
    DOC_END;
    typedef bool (DERIVED::*MyMethod)(const std::string &, const std::string &);
    return Method<DERIVED>::call((MyMethod)&DERIVED::isClipActive,cx,obj,argc,argv,rval);
}
template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::isCharacterActive(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Returns if a character with a given name is active");
    DOC_PARAM("theCharacterName", "", DOC_TYPE_STRING);
    DOC_RVAL("isActive", DOC_TYPE_BOOLEAN);
    DOC_END;
    typedef bool (DERIVED::*MyMethod)(const std::string &);
    return Method<DERIVED>::call((MyMethod)&DERIVED::isCharacterActive,cx,obj,argc,argv,rval);
}
template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::stopCharacter(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Stops an animated character with a given name");
    DOC_PARAM("theCharacterName", "", DOC_TYPE_STRING);
    DOC_END;
    typedef void (DERIVED::*MyMethod)(const std::string &);
    return Method<DERIVED>::call((MyMethod)&DERIVED::stopCharacter,cx,obj,argc,argv,rval);
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::activateGLContext(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Use this function to switch the OpenGL context to an offscreen window.");
    DOC_END;
    DERIVED * mySelf;
    convertFrom(cx, OBJECT_TO_JSVAL(obj), mySelf);
    mySelf->activateGLContext();
    return JS_TRUE;
}
template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::deactivateGLContext(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Use this function to switch of an OpenGL context of an offscreen window.");
    DOC_END;
    DERIVED * mySelf;
    convertFrom(cx, OBJECT_TO_JSVAL(obj), mySelf);
    mySelf->deactivateGLContext();
    return JS_TRUE;
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::clearBuffers(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Clear the specified buffers.");
    DOC_PARAM("theBufferMask", "", DOC_TYPE_INTEGER);
    DOC_END;
    typedef void (DERIVED::*MyMethod)(unsigned int);
    return Method<DERIVED>::call((MyMethod)&DERIVED::clearBuffers,cx,obj,argc,argv,rval);
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::preRender(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Execute the pre-render JavaScript and component functions.");
    DOC_END;
    DERIVED * mySelf;
    convertFrom(cx, OBJECT_TO_JSVAL(obj), mySelf);
    mySelf->preRender();
    return JS_TRUE;
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::render(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Render the scene to all viewports, calls pre- and post-viewport JavaScript functions.");
    DOC_END;
    DERIVED * mySelf;
    convertFrom(cx, OBJECT_TO_JSVAL(obj), mySelf);
    mySelf->render();
    return JS_TRUE;
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::postRender(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Execute the post-render JavaScript and component functions.");
    DOC_END;
    DERIVED * mySelf;
    convertFrom(cx, OBJECT_TO_JSVAL(obj), mySelf);
    mySelf->postRender();
    return JS_TRUE;
}

template<class DERIVED>
JSBool
JSAbstractRenderWindow<DERIVED>::swapBuffers(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    DOC_BEGIN("Swap back and front buffers.");
    DOC_END;
    DERIVED * mySelf;
    convertFrom(cx, OBJECT_TO_JSVAL(obj), mySelf);
    mySelf->swapBuffers();
    return JS_TRUE;
}

template<class DERIVED>
JSFunctionSpec * JSAbstractRenderWindow<DERIVED>::BaseStaticFunctions() {
    AC_DEBUG << "Registering class '"<< JSWrapper<DERIVED, asl::Ptr<DERIVED>, StaticAccessProtocol>::ClassName()<<"'";
    static JSFunctionSpec myFunctions[] = {
        // name                    native          nargs
        {0}
    };
    return myFunctions;
}
template<class DERIVED>
JSFunctionSpec * JSAbstractRenderWindow<DERIVED>::BaseFunctions() {
    static JSFunctionSpec myFunctions[] = {
        // name                  native                   nargs
        {"setTimeout",         setTimeout,               3},
        {"setInterval",        setInterval,              3},
        {"clearTimeout",       clearTimeout,             1},
        {"clearInterval",      clearInterval,            1},
        {"saveBuffer",         saveBuffer,               3},
        {"copyBufferToTexture", copyBufferToTexture,     3},
        {"getRenderer",        getRenderer,              0},
        {"addExtension",       addExtension,             1},
        {"setSceneAndCanvas",  setSceneAndCanvas,        2},
        {"hasCap",             hasCap,                   1},
        {"hasCapAsString",     hasCapAsString,           1},
        {"printStatistics",    printStatistics,          0}, // base class
        {"getImagePixel",      getImagePixel,            3},
        {"setImagePixel",      setImagePixel,            4},
        {"getPixel",           getPixel,                 4},
        {"performRequest",     performRequest,           1},
        // text rendering
        {"renderText",         renderText,               5},
        {"renderTextAsImage",  renderTextAsImage,        7},
        {"getTextCursorPosition", getTextCursorPosition, 0},
        {"getTextGlyphPositions", getTextGlyphPositions, 0},        
        {"getTextLineWidths",  getTextLineWidths,        0},
        {"getTextMaxWidth",    getTextMaxWidth,          0},
        {"getFontMetrics",     getFontMetrics,           1},
        {"getGlyphMetrics",    getGlyphMetrics,          2},
        {"getKerning",         getKerning,               3},
        {"hasGlyph",           hasGlyph,                 2},
        // animations
        {"runAnimations",      runAnimations,            1},
        {"playClip",           playClip,                 3},
        {"setClipLoops",       setClipLoops,             3},
        {"setClipForwardDirection", setClipForwardDirection,3},
        {"getLoops",           getLoops,                 2},
        {"isClipActive",       isClipActive,             2},
        {"isCharacterActive",  isCharacterActive,        1},
        {"stopCharacter",      stopCharacter,            1},
        {"activateGLContext",  activateGLContext,        0},
        {"deactivateGLContext",  deactivateGLContext,    0},
        // rendering
        {"clearBuffers",  clearBuffers,    1},
        {"preRender",  preRender,          0},
        {"render",  render,                0},
        {"postRender",  postRender,        0},
        {"swapBuffers",  swapBuffers,      0},
        {0}
    };
    return myFunctions;
}

#define DEFINE_GL_ENUM( NAME ) { #NAME, PROP_ ## NAME, NAME}
template<class DERIVED>
JSConstIntPropertySpec * JSAbstractRenderWindow<DERIVED>::ConstIntProperties() {
    static JSConstIntPropertySpec myProperties[] = {
        DEFINE_GL_ENUM(GL_RED),
        DEFINE_GL_ENUM(GL_BLUE),
        DEFINE_GL_ENUM(GL_GREEN),
        DEFINE_GL_ENUM(GL_ALPHA),
        DEFINE_GL_ENUM(GL_RGB),
        DEFINE_GL_ENUM(GL_BGR),
        DEFINE_GL_ENUM(GL_RGBA),
        DEFINE_GL_ENUM(GL_BGRA),
        DEFINE_GL_ENUM(GL_DEPTH_COMPONENT),

        DEFINE_GL_ENUM(GL_UNSIGNED_BYTE),
        DEFINE_GL_ENUM(GL_BYTE),
        DEFINE_GL_ENUM(GL_BITMAP),
        DEFINE_GL_ENUM(GL_UNSIGNED_SHORT),
        DEFINE_GL_ENUM(GL_SHORT),
        DEFINE_GL_ENUM(GL_UNSIGNED_INT),
        DEFINE_GL_ENUM(GL_INT),
        DEFINE_GL_ENUM(GL_FLOAT),

        DEFINE_GL_ENUM(GL_COLOR_BUFFER_BIT),
        DEFINE_GL_ENUM(GL_DEPTH_BUFFER_BIT),
        DEFINE_GL_ENUM(GL_STENCIL_BUFFER_BIT),
        DEFINE_GL_ENUM(GL_ACCUM_BUFFER_BIT),
        {0}
    };
    return myProperties;
};

template<class DERIVED>
JSPropertySpec * JSAbstractRenderWindow<DERIVED>::BaseProperties() {
    static JSPropertySpec myProperties[] = {
        {"scene",           PROP_scene,             JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED}, // node
        {"width",           PROP_width,             JSPROP_READONLY|JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED},
        {"height",          PROP_height,            JSPROP_READONLY|JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED},
        {"forceFullGC",     PROP_forceFullGC,       JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED}, // boolean
        {"pause",           PROP_pause,             JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED}, // boolean
        {"visible",         PROP_visible,           JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED}, // boolean
        {"eventListener",   PROP_eventListener,     JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED},
        {"canvas",          PROP_canvas,            JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED}, // Node
        {"camera",          PROP_camera,            JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED}, // Node
        {"projectionmatrix",PROP_projectionmatrix,  JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_READONLY|JSPROP_SHARED},
        {"renderingCaps",   PROP_renderingCaps,     JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED}, // unsined int
        {"glVendorString", PROP_glVendorString,    JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED|JSPROP_READONLY},
        {"glVersionString", PROP_glVersionString,    JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED|JSPROP_READONLY},
        {"glRendererString",PROP_glRendererString,    JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED|JSPROP_READONLY},
        {"glExtensionStrings",PROP_glExtensionStrings,    JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED|JSPROP_READONLY},
        {"fixedFrameTime",  PROP_fixedFrameTime,    JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED}, // unsined int
        {"fps",             PROP_fps,               JSPROP_READONLY|JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED}, // double
        {"multisamples",    PROP_multisamples,      JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED}, // double
        {"wireframe",       PROP_wireframe,         JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED},
        {"drawnormals",     PROP_drawnormals,       JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED},
        {"lighting",        PROP_lighting,  JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED},
        {"flatshading",     PROP_flatshading,  JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED},
        {"texturing",       PROP_texturing,  JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED},
        {"backfaceCulling", PROP_backfaceCulling,  JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED},
        {"culling",         PROP_culling,  JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED},
        {"backgroundColor", PROP_backgroundColor,  JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED},
        {"debugCulling",    PROP_debugCulling,  JSPROP_ENUMERATE|JSPROP_PERMANENT|JSPROP_SHARED},
        {0}
    };
    return myProperties;
}

template<class DERIVED>
JSBool JSAbstractRenderWindow<DERIVED>::getPropertySwitch(DERIVED & theNative, unsigned long theID,
        JSContext *cx, JSObject *obj, jsval id, jsval *vp)
{
    //std::cerr << "JSRenderWindow::getPropertySwitch: id ="<<int(theID)<<std::endl;
    switch (theID) {
        case PROP_forceFullGC:
            *vp = as_jsval(cx, theNative.getForceFullGC()); //TODO: remove global
            return JS_TRUE;
        case PROP_visible:
            *vp = as_jsval(cx, theNative.getVisibility());
            return JS_TRUE;
        case PROP_pause:
            *vp = as_jsval(cx, theNative.getPause()); //TODO: remove global
            return JS_TRUE;
        case PROP_scene:
            *vp = as_jsval(cx, theNative.getCurrentScene());
            return JS_TRUE;
        case PROP_eventListener:
            *vp = OBJECT_TO_JSVAL(theNative.getEventListener());
            return JS_TRUE;
        case PROP_width:
            *vp = as_jsval(cx, theNative.getWidth());
            return JS_TRUE;
        case PROP_height:
            *vp = as_jsval(cx, theNative.getHeight());
            return JS_TRUE;
        case PROP_projectionmatrix:
            //*vp = as_jsval(cx, theNative.getSingleViewport()->y60::Viewport::get<y60::ProjectionMatrixTag>());
            {AC_WARNING << "JSAbstractRenderWindow property 'projectionmatrix' is deprecated.";}
            return JS_TRUE;
        case PROP_camera:
            {
                y60::ViewportPtr myViewport = theNative.getSingleViewport();
                *vp = as_jsval(cx, myViewport->getNode().getElementById(
                            myViewport->y60::Viewport::get<y60::CameraTag>()));
                return JS_TRUE;
            }
        case PROP_flatshading:
            *vp = as_jsval(cx, theNative.getSingleViewport()->y60::Viewport::template get<y60::ViewportFlatshadingTag>());
            return JS_TRUE;
        case PROP_texturing:
            *vp = as_jsval(cx, theNative.getSingleViewport()->y60::Viewport::template get<y60::ViewportTexturingTag>());
            return JS_TRUE;
        case PROP_wireframe:
            *vp = as_jsval(cx, theNative.getSingleViewport()->y60::Viewport::template get<y60::ViewportWireframeTag>());
            return JS_TRUE;
        case PROP_drawnormals:
            *vp = as_jsval(cx, theNative.getSingleViewport()->y60::Viewport::template get<y60::ViewportDrawNormalsTag>());
            return JS_TRUE;
        case PROP_backfaceCulling:
            *vp = as_jsval(cx, theNative.getSingleViewport()->y60::Viewport::template get<y60::ViewportBackfaceCullingTag>());
            return JS_TRUE;
        case PROP_culling:
            *vp = as_jsval(cx, theNative.getSingleViewport()->y60::Viewport::template get<y60::ViewportCullingTag>());
            return JS_TRUE;
        case PROP_debugCulling:
            *vp = as_jsval(cx, theNative.getSingleViewport()->y60::Viewport::template get<y60::ViewportDebugCullingTag>());
            return JS_TRUE;
        case PROP_lighting:
            *vp = as_jsval(cx, theNative.getSingleViewport()->y60::Viewport::template get<y60::ViewportLightingTag>());
            return JS_TRUE;
        case PROP_backgroundColor:
            {
                y60::CanvasPtr myCanvas = theNative.getCanvas()->dom::Node::template getFacade<y60::Canvas>();
                *vp = as_jsval(cx, myCanvas->y60::Canvas::get<y60::CanvasBackgroundColorTag>());
                return JS_TRUE;
            }
        case PROP_canvas:
            *vp = as_jsval(cx, theNative.getCanvas());
            return JS_TRUE;
        case PROP_renderingCaps:
            *vp = as_jsval(cx, theNative.getRenderingCaps());
            return JS_TRUE;
        case PROP_glVersionString:
            *vp = as_jsval(cx, theNative.getGLVersionString());
            return JS_TRUE;
        case PROP_glVendorString:
            *vp = as_jsval(cx, theNative.getGLVendorString());
            return JS_TRUE;
        case PROP_glRendererString:
            *vp = as_jsval(cx, theNative.getGLRendererString());
            return JS_TRUE;
        case PROP_glExtensionStrings:
            {
                std::vector<std::string> myTokens;
                theNative.getGLExtensionStrings(myTokens);
                *vp = as_jsval(cx, myTokens);
                return JS_TRUE;
            }
        case PROP_fixedFrameTime:
            *vp = as_jsval(cx, theNative.getFixedDeltaT());
            return JS_TRUE;
        case PROP_fps:
            *vp = as_jsval(cx, theNative.getFrameRate());
            return JS_TRUE;
        case PROP_multisamples:
            *vp = as_jsval(cx, theNative.getMultisamples());
            return JS_TRUE;
        default:
            JS_ReportError(cx,"JSAbstractRenderWindow::getProperty: index %d out of range", theID);
            return JS_FALSE;
    }
}

template<class DERIVED>
JSBool JSAbstractRenderWindow<DERIVED>::setPropertySwitch(NATIVE & theNative, unsigned long theID, JSContext *cx,
        JSObject *obj, jsval id, jsval *vp)
{
    jsval dummy;
    switch (theID) {
        case PROP_forceFullGC:
            {
                typedef void (DERIVED::*MyMethod)(bool);
                return Method<DERIVED>::call((MyMethod)&DERIVED::setForceFullGC, cx, obj, 1, vp, &dummy);
            }
        case PROP_visible:
            {
                typedef void (DERIVED::*MyMethod)(bool);
                return Method<DERIVED>::call((MyMethod)&DERIVED::setVisibility, cx, obj, 1, vp, &dummy);
            }
        case PROP_pause:
            {
                typedef void (DERIVED::*MyMethod)(bool);
                return Method<DERIVED>::call((MyMethod)&DERIVED::setPause, cx, obj, 1, vp, &dummy);
            }
        case PROP_eventListener:
            {
                JSObject * myListener;
                if (convertFrom(cx, *vp, myListener)) {
                    theNative.setJSContext(cx);
                    theNative.setEventListener( myListener);
                    return JS_TRUE;
                }
                return JS_FALSE;
            }
        case PROP_camera:
            {
                y60::ViewportPtr myViewport = theNative.getSingleViewport();
                dom::NodePtr myCameraNode;
                if (!convertFrom(cx, *vp, myCameraNode)) {
                    JS_ReportError(cx,"JSAbstractRenderWindow::set camera: rvalue is not a node");
                    return JS_FALSE;
                }
                myViewport->y60::Viewport::set<y60::CameraTag>(
                        myCameraNode->getAttributeString(y60::ID_ATTRIB)
                );
                return JS_TRUE;
            }
        case PROP_scene: {
            y60::ScenePtr myScene;
            if (*vp == JSVAL_NULL || !convertFrom(cx, *vp, myScene)) {
                throw JSArgMismatch("Failed to convert argument to type y60::Scene", PLUS_FILE_LINE);
            }
            if (theNative.setScene(myScene)) {
                return JS_TRUE;
            } else {
                return JS_FALSE;
            }
        }
        case PROP_lighting:
            return setViewportAttribute<y60::ViewportLightingTag>(theNative, cx, vp);
        case PROP_flatshading:
            return setViewportAttribute<y60::ViewportFlatshadingTag>(theNative, cx, vp);
        case PROP_backfaceCulling:
            return setViewportAttribute<y60::ViewportBackfaceCullingTag>(theNative, cx, vp);
        case PROP_culling:
            return setViewportAttribute<y60::ViewportCullingTag>(theNative, cx, vp);
        case PROP_debugCulling:
            return setViewportAttribute<y60::ViewportDebugCullingTag>(theNative, cx, vp);
        case PROP_wireframe:
            return setViewportAttribute<y60::ViewportWireframeTag>(theNative, cx, vp);
        case PROP_drawnormals:
            return setViewportAttribute<y60::ViewportDrawNormalsTag>(theNative, cx, vp);
        case PROP_texturing:
            return setViewportAttribute<y60::ViewportTexturingTag>(theNative, cx, vp);
        case PROP_backgroundColor:
            {
                y60::CanvasBackgroundColorTag::TYPE theColor;
                if (!convertFrom(cx, *vp, theColor)) {
                    asl::Vector3f myColor;
                    if (!convertFrom(cx, *vp, myColor)) {
                        JS_ReportError(cx,"JSAbstractRenderWindow::set background color must be Vector3f or Vector4f.");
                        return JS_FALSE;
                    }
                    theColor[0] = myColor[0];
                    theColor[1] = myColor[1];
                    theColor[2] = myColor[2];
                    theColor[3] = 1;
                }
                theNative.getCanvas()->dom::Node::getFacade<y60::Canvas>()->y60::Canvas::set<y60::CanvasBackgroundColorTag>(theColor);
                return JS_TRUE;
            }
        case PROP_canvas:
            {
                dom::NodePtr myCanvasNode;
                if (convertFrom(cx, *vp, myCanvasNode)) {
                    theNative.setCanvas(myCanvasNode);
                    return JS_TRUE;
                }
                return JS_FALSE;
            }
        case PROP_renderingCaps:
            unsigned myFlags;
            if (convertFrom(cx, *vp, myFlags)) {
                theNative.setRenderingCaps( myFlags );
                return JS_TRUE;
            }
            return JS_FALSE;
        case PROP_fixedFrameTime:
            {
                typedef void (DERIVED::*MyMethod)(const double &);
                return Method<DERIVED>::call((MyMethod)&DERIVED::setFixedDeltaT, cx, obj, 1, vp, &dummy);
            }
        case PROP_multisamples:
            {
                typedef void (DERIVED::*MyMethod)(unsigned);
                return Method<DERIVED>::call((MyMethod)&DERIVED::setMultisamples, cx, obj, 1, vp, &dummy);
            }
        default:
            JS_ReportError(cx,"JSAbstractRenderWindow::setPropertySwitch: index %d out of range", theID);
            return JS_FALSE;
    }
}


}

/* vim: set filetype=cpp : */
