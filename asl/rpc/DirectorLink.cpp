// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 1999
// Object-Oriented Concepts, Inc.
// Billerica, MA, USA
//
// Copyright (c) 1999
// Object-Oriented Concepts GmbH
// Ettlingen, Germany
//
// All Rights Reserved
//
// **********************************************************************

// Version: 3.1.2
// License: 2-5-990601-1

#include <OB/CORBA.h>
#include <OB/TemplateI.h>
#include "DirectorLink.h"

//
// IDL:DirectorLink:1.0
//
#ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OBObjVar< DirectorLink >;
template class OBObjForSeq< DirectorLink >;
#else
#ifdef HAVE_PRAGMA_DEFINE
#pragma define(OBObjVar< DirectorLink >)
#pragma define(OBObjForSeq< DirectorLink >)
#endif
#endif

void
OBDuplicate(DirectorLink_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(DirectorLink_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

DirectorLink_ptr
DirectorLink::_narrow(CORBA_Object_ptr p)
{
    if(!CORBA_is_nil(p))
    {
        void* v = p -> _OB_narrowHelp("IDL:DirectorLink:1.0");

        if(v)
            return _duplicate((DirectorLink_ptr)v);

        if(p -> _OB_remoteIsA("IDL:DirectorLink:1.0"))
        {
            DirectorLink_ptr val = new DirectorLink;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

void*
DirectorLink::_OB_narrowHelp(const char* _ob_id) const
{
    if(strcmp("IDL:DirectorLink:1.0", _ob_id) == 0)
        return (void*)this;
    else
        return CORBA_Object::_OB_narrowHelp(_ob_id);
}

const char*
DirectorLink::_OB_typeId() const
{
    return "IDL:DirectorLink:1.0";
}

void
OBUnmarshal(DirectorLink_ptr& val, const CORBA_Octet*& coct, bool swap)
{
    DirectorLink_var old = val;
    CORBA_Object_var p;
    OBUnmarshal(p.inout(), coct, swap);

    if(!CORBA_is_nil(p))
    {
        void* v = p -> _OB_narrowHelp("IDL:DirectorLink:1.0");

        if(v)
            val = DirectorLink::_duplicate((DirectorLink_ptr)v);
        else
        {
            assert_nca(!(p -> _is_local() && p -> _is_dynamic()), OBNCADynamicAsStatic);
            assert(!p -> _is_local());
            val = new DirectorLink;
            val -> _OB_copyFrom(p);
        }
    }
    else
        val = DirectorLink::_nil();
}

OBTypeCodeConst _tc_DirectorLink(
"010000000e00000031000000010000001500000049444c3a4469726563746f724c696e6b3a312"
"e30000000000d0000004469726563746f724c696e6b00"
);

void
operator<<=(CORBA_Any& any, DirectorLink_ptr val)
{
    OBObjAny* o = new OBObjAny;
    o -> b = CORBA_Object::_duplicate(val);
    o -> d = CORBA_Object::_duplicate(val);
    any.replace(_tc_DirectorLink, o, true);
}

void
operator<<=(CORBA_Any& any, DirectorLink_ptr* val)
{
    OBObjAny* o = new OBObjAny;
    o -> b = *val;
    o -> d = CORBA_Object::_duplicate(*val);
    any.replace(_tc_DirectorLink, o, true);
}

CORBA_Boolean
operator>>=(const CORBA_Any& any, DirectorLink_ptr& val)
{
    if(any.check_type(_tc_DirectorLink))
    {
        OBObjAny* o = (OBObjAny*)any.value();
        assert(o);

        if(!CORBA_is_nil(o -> d))
        {
            void* v = o -> d -> _OB_narrowHelp("IDL:DirectorLink:1.0");

            if(v)
                val = (DirectorLink_ptr)v;
            else
            {
                assert_nca(!(o -> d -> _is_local() && o -> d -> _is_dynamic()), OBNCADynamicAsStatic);
                assert(!o -> d -> _is_local());
                val = new DirectorLink;
                val -> _OB_copyFrom(o -> d);
                OBObjAny* no = new OBObjAny;
                no -> b = CORBA_Object::_duplicate(o -> b);
                no -> d = val;
                ((CORBA_Any&)any).replace(_tc_DirectorLink, no, true);
            }
        }
        else
            val = DirectorLink::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:DirectorLink/callY50:1.0
//
char*
DirectorLink::callY50(const char* _ob_a0)
{
    if(CORBA_is_nil(_ob_clt_))
        throw CORBA_NO_IMPLEMENT();

    CORBA_ULong _ob_off = _ob_clt_ -> offset(this, "callY50");
    CORBA_ULong _ob_cnt = _ob_off;
    OBMarshalCount(_ob_a0, _ob_cnt);

    OBBuffer _ob_buf(_ob_cnt);
    CORBA_Octet* _ob_o = _ob_buf.data + _ob_off;
    OBMarshal(_ob_a0, _ob_o);

    bool _ob_sw, _ob_ex, _ob_fo;
    _ob_off = _ob_clt_ -> request(this, "callY50", _ob_buf, _ob_sw, _ob_ex, _ob_fo, _ob_tout_, _ob_retry_);

    const CORBA_Octet* _ob_co = _ob_buf.data + _ob_off;

    if(_ob_fo)
    {
        _OB_forward(_ob_co, _ob_sw);
        return callY50(_ob_a0);
    }

    if(_ob_ex)
        throw CORBA_UNKNOWN();

    char* _ob_r = 0;
    OBUnmarshal(_ob_r, _ob_co, _ob_sw);
    return _ob_r;
}
